#! /usr/bin/env python

##############################################
# Express a truth table as an NchooseK block #
# By Scott Pakin <pakin@lanl.gov>            #
##############################################

import argparse
import string
import sys

class TruthTable(object):
    'Represent a truth table and various operations on it.'

    def __init__(self):
        'Initialize a truth table.'
        self.nrows = 0
        self.ncols = 0

    def read_from_file(self, fd):
        'Read a truth table from a file.'
        self.tbl = set()
        for line in fd.readlines():
            hash = line.find('#')
            if hash != -1:
                line = line[:hash]
            tbl_line = []
            fields = line.split()
            nf = len(fields)
            if nf == 0:
                continue
            if self.ncols == 0:
                self.ncols = nf
            elif self.ncols != nf:
                raise Exception('mismatched column counts')
            for f in fields:
                if f.lower() in ['0', '-1', 'f', 'false']:
                    tbl_line.append(0)
                elif f.lower() in ['1', '+1', 't', 'true']:
                    tbl_line.append(1)
            self.tbl.add(tuple(tbl_line))
        self.nrows = len(self.tbl)

    def _all_sequences(self, vals, n):
        'Return all length-n sequences composed of vals.'
        if n == 0:
            return [[]]
        else:
            return [[e] + prev
                    for e in vals
                    for prev in self._all_sequences(vals, n - 1)]

    def _find_k_values(self, weights):
        '''Return a set of k values given a list of column weights.  Return
        None if no such k values can be found.'''
        valid_tallies = set()
        invalid_tallies = set()
        for seq in self._all_sequences([0, 1], self.ncols):
            row = tuple(seq)
            s = sum([row[c]*weights[c] for c in range(self.ncols)])
            if row in tt.tbl:
                valid_tallies.add(s)
            else:
                invalid_tallies.add(s)
        overlap = valid_tallies.intersection(invalid_tallies)
        if len(overlap) == 0:
            return valid_tallies
        else:
            return None

    def to_nck(self):
        '''Return a list of column weights and a list of k values that reproduce
        the truth table.'''
        weight_list = list(range(1, self.ncols*2))  # QUERY: Is self.ncols*2 sufficient, or does it need to be 2**(self.ncols - 1)?
        for weights in sorted(self._all_sequences(weight_list, tt.ncols), key=sum):
            kvals = self._find_k_values(weights)
            if kvals != None:
                return weights, kvals
        return None, None

###########################################################################

# Parse the command line.
parser = argparse.ArgumentParser(description='Express a truth table with NchooseK.')
parser.add_argument('infile', nargs='?', type=open, default=sys.stdin, metavar='FILE',
                    help='name of a file containing a truth table to express')
parser.add_argument('--compress', '-c', action='store_true',
                    help='display repeated variable names only once but with a repetition count')
cl_args = parser.parse_args()

# Read a truth table.
tt = TruthTable()
tt.read_from_file(cl_args.infile)

# Convert the truth table to a pretty-printed NchooseK primitive.
weights, kvals = tt.to_nck()
if weights == None:
    sys.exit('Failed to convert the truth table')
if cl_args.compress:
    col_names = []
    for c, n in zip(string.ascii_uppercase, weights):
        if n == 1:
            col_names.append(c)
        else:
            col_names.append('%s*%d' % (c, n))
else:
    col_names = ''.join([c*n for c, n in zip(string.ascii_uppercase, weights)])
kval_names = [str(k) for k in sorted(kvals)]
print('nck([%s], {%s})' % (', '.join(col_names), ', '.join(kval_names)))
